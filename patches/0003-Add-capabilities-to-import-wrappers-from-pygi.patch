From a727be30ba283027b2c8a5a3e1c60f85b45a8667 Mon Sep 17 00:00:00 2001
From: Simon van der Linden <svdlinden@src.gnome.org>
Date: Sat, 7 Nov 2009 16:43:35 +0100
Subject: [PATCH 3/4] Add capabilities to import wrappers from pygi

At instance creation for boxed and pointers, at lookup for objects,
when the gtype has no wrapper yet, a wrapper may be imported from pygi.

The feature is turned on at configure time by --enable-pygi.

Because we couldn't create a circular build dependency, PyGI's import function and
API definition had to be copied in this tree.
---
 configure.ac            |    8 +++++++
 gobject/pygboxed.c      |   14 ++++++++++++
 gobject/pygi-external.h |   54 +++++++++++++++++++++++++++++++++++++++++++++++
 gobject/pygobject.c     |   14 ++++++++++++
 gobject/pygpointer.c    |   15 +++++++++++++
 5 files changed, 105 insertions(+), 0 deletions(-)
 create mode 100644 gobject/pygi-external.h

diff --git a/configure.ac b/configure.ac
index 0bf7610..dc8dea6 100644
--- a/configure.ac
+++ b/configure.ac
@@ -215,6 +215,14 @@ if test "$enable_introspection" != no; then
   fi
 fi
 
+AC_ARG_ENABLE(pygi,
+  AC_HELP_STRING([--enable-pygi], [Use PyGI to create wrappers for introspection-enabled types]),
+  enable_pygi=$enableval,
+  enable_pygi=no)
+if test "$enable_pygi" != no; then
+    AC_DEFINE(ENABLE_PYGI,1,Use PyGI to create wrappers for introspection-enabled types)
+fi
+
 dnl add required cflags ...
 if test "x$GCC" = "xyes"; then
   JH_ADD_CFLAG([-Wall])
diff --git a/gobject/pygboxed.c b/gobject/pygboxed.c
index eb274a2..b9cf6b3 100644
--- a/gobject/pygboxed.c
+++ b/gobject/pygboxed.c
@@ -28,6 +28,10 @@
 #include "pygobject-private.h"
 #include "pygboxed.h"
 
+#if ENABLE_PYGI
+#    include "pygi-external.h"
+#endif
+
 GQuark pygboxed_type_key;
 GQuark pygboxed_marshal_key;
 
@@ -182,6 +186,16 @@ pyg_boxed_new(GType boxed_type, gpointer boxed, gboolean copy_boxed,
     }
 
     tp = g_type_get_qdata(boxed_type, pygboxed_type_key);
+
+#if ENABLE_PYGI
+    if (tp == NULL && _pygi_import() == 0) {
+        tp = (PyTypeObject *)pygi_type_import_by_g_type(boxed_type);
+        if (tp == NULL) {
+            PyErr_Clear();
+        }
+    }
+#endif /* ENABLE_PYGI */
+
     if (!tp)
 	tp = (PyTypeObject *)&PyGBoxed_Type; /* fallback */
     self = PyObject_NEW(PyGBoxed, tp);
diff --git a/gobject/pygi-external.h b/gobject/pygi-external.h
new file mode 100644
index 0000000..51eef77
--- /dev/null
+++ b/gobject/pygi-external.h
@@ -0,0 +1,54 @@
+/* -*- Mode: C; c-basic-offset: 4 -*-
+ * vim: tabstop=4 shiftwidth=4 expandtab
+ */
+
+#ifndef _PYGI_EXTERNAL_H_
+#define _PYGI_EXTERNAL_H_
+
+#include <Python.h>
+#include <glib.h>
+
+struct PyGI_API {
+    PyObject* (*type_import_by_g_type) (GType g_type);
+};
+
+static struct PyGI_API *PyGI_API = NULL;
+
+#define pygi_type_import_by_g_type (PyGI_API->type_import_by_g_type)
+
+static int
+_pygi_import (void)
+{
+    PyObject *module;
+    PyObject *api;
+
+    if (PyGI_API != NULL) {
+        return 1;
+    }
+
+    module = PyImport_ImportModule("gi");
+    if (module == NULL) {
+        return -1;
+    }
+
+    api = PyObject_GetAttrString(module, "_API");
+    if (api == NULL) {
+        Py_DECREF(module);
+        return -1;
+    }
+    if (!PyCObject_Check(api)) {
+        Py_DECREF(module);
+        Py_DECREF(api);
+        PyErr_Format(PyExc_TypeError, "gi._API must be cobject, not %s",
+            api->ob_type->tp_name);
+        return -1;
+    }
+
+    PyGI_API = (struct PyGI_API *)PyCObject_AsVoidPtr(api);
+
+    Py_DECREF(api);
+
+    return 0;
+}
+
+#endif /* _PYGI_EXTERNAL_H_ */
diff --git a/gobject/pygobject.c b/gobject/pygobject.c
index b4274e1..19c90ff 100644
--- a/gobject/pygobject.c
+++ b/gobject/pygobject.c
@@ -29,6 +29,10 @@
 #include "pyginterface.h"
 #include "pygparamspec.h"
 
+#if ENABLE_PYGI
+#    include "pygi-external.h"
+#endif
+
 
 static void pygobject_dealloc(PyGObject *self);
 static int  pygobject_traverse(PyGObject *self, visitproc visit, void *arg);
@@ -871,6 +875,16 @@ pygobject_lookup_class(GType gtype)
     py_type = g_type_get_qdata(gtype, pygobject_class_key);
     if (py_type == NULL) {
 	py_type = g_type_get_qdata(gtype, pyginterface_type_key);
+
+#if ENABLE_PYGI
+    if (py_type == NULL && _pygi_import() == 0) {
+        py_type = (PyTypeObject *)pygi_type_import_by_g_type(gtype);
+        if (py_type == NULL) {
+            PyErr_Clear();
+        }
+    }
+#endif /* ENABLE_PYGI */
+
 	if (py_type == NULL) {
 	    py_type = pygobject_new_with_interfaces(gtype);
 	    g_type_set_qdata(gtype, pyginterface_type_key, py_type);
diff --git a/gobject/pygpointer.c b/gobject/pygpointer.c
index ee0a8da..cdcb320 100644
--- a/gobject/pygpointer.c
+++ b/gobject/pygpointer.c
@@ -28,6 +28,11 @@
 #include "pygobject-private.h"
 #include "pygpointer.h"
 
+#if ENABLE_PYGI
+#    include "pygi-external.h"
+#endif
+
+
 GQuark pygpointer_class_key;
 
 PYGLIB_DEFINE_TYPE("gobject.GPointer", PyGPointer_Type, PyGPointer);
@@ -155,6 +160,16 @@ pyg_pointer_new(GType pointer_type, gpointer pointer)
     }
 
     tp = g_type_get_qdata(pointer_type, pygpointer_class_key);
+
+#if ENABLE_PYGI
+    if (tp == NULL && _pygi_import() == 0) {
+        tp = (PyTypeObject *)pygi_type_import_by_g_type(pointer_type);
+        if (tp == NULL) {
+            PyErr_Clear();
+        }
+    }
+#endif /* ENABLE_PYGI */
+
     if (!tp)
 	tp = (PyTypeObject *)&PyGPointer_Type; /* fallback */
     self = PyObject_NEW(PyGPointer, tp);
-- 
1.6.3.3

